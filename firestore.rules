/**
 * @fileoverview Firestore Security Rules for IPS Virtual – Salud en Casa.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles
 * and allows public read access to the `departments` and `cities` collections.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}`, where `{userId}` must match the
 *   authenticated user's UID. This ensures that users can only manage their own profiles.
 * - Departments and Cities are stored in top-level collections (`/departments/{departmentId}`
 *   and `/cities/{cityId}`), allowing public read access.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - The `users` collection should not be listable, so `list` is denied.
 * - Departments and cities are publicly readable but not writable by clients.
 * - The rules do not validate the data schema beyond requiring that the `id` field
 *   in user documents matches the `userId` in the path, enforcing ownership.
 *
 * Denormalization for Authorization:
 * The `users` collection enforces that the document ID matches the authenticated user's UID.
 * This avoids the need for additional `get()` calls to verify ownership.
 *
 * Structural Segregation:
 * Public data (departments, cities) is stored in separate, top-level collections,
 * while private user data is stored under the `/users/{userId}` path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles. Only the authenticated user can read or write their own profile.
     * @path /users/{userId}
     * @allow (create) - User 'aoz5fhQSEbdsGNxUpXbT7SmcVgu1' can create their own profile at /users/aoz5fhQSEbdsGNxUpXbT7SmcVgu1 with matching id.
     * @allow (get, update, delete) - User 'aoz5fhQSEbdsGNxUpXbT7SmcVgu1' can read/update/delete their own profile at /users/aoz5fhQSEbdsGNxUpXbT7SmcVgu1.
     * @deny  (create) - User 'aoz5fhQSEbdsGNxUpXbT7SmcVgu1' cannot create a profile at /users/otherUserId.
     * @deny  (get, update, delete) - User 'aoz5fhQSEbdsGNxUpXbT7SmcVgu1' cannot read/update/delete the profile of another user at /users/otherUserId.
     * @deny  (list) - No one can list all users.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree, and validates relational integrity between documents.
     */
    match /users/{userId} {
      // Validate that the userId matches the authenticated user's UID
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      // Validate that the user is signed in and owns the resource and that the resource exists (update/delete)
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      //isSigned in
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      
      // Allow authenticated users to list users (needed for querying patients, doctors, etc.)
      // The application uses role-based queries to filter users appropriately
      allow list: if isSignedIn();

      // On create, enforce that the document ID matches the authenticated user's UID.
      // This links the path to the user.
      allow create: if isSignedIn() && request.resource.data.id == userId;

      // On update, allow if user is the owner and either:
      // 1. The id field is not being changed (if it exists in the update), OR
      // 2. The id field is not included in the update (partial update)
      allow update: if isExistingOwner(userId) && 
        (!("id" in request.resource.data) || request.resource.data.id == resource.data.id);

      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to the departments collection.  No client writes allowed.
     * @path /departments/{departmentId}
     * @allow (get, list) - Any user can read departments.
     * @deny  (create, update, delete) - No user can create, update, or delete departments via client.
     * @principle Allows public read access to static data; restricts write access.
     */
    match /departments/{departmentId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to the cities collection.  No client writes allowed.
     * @path /cities/{cityId}
     * @allow (get, list) - Any user can read cities.
     * @deny  (create, update, delete) - No user can create, update, or delete cities via client.
     * @principle Allows public read access to static data; restricts write access.
     */
    match /cities/{cityId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages access to appointments collection.
     * @path /appointments/{appointmentId}
     * @allow (get, list) - Authenticated users can read appointments (filtered by userId or doctorId in queries).
     * @allow (create, update, delete) - Authenticated users can manage appointments.
     * @principle Allows authenticated users to manage their appointments.
     * @fields userId, doctorId, doctorName, serviceName, date, time, status, notes, diagnosis (optional - added when consultation is completed)
     * @status values: pendiente, confirmada, cancelada, completada
     */
    match /appointments/{appointmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to formulas (prescriptions) collection.
     * @path /formulas/{formulaId}
     * @allow (get, list) - Authenticated users can read formulas (app filters by patientId/doctorId).
     * @allow (create, update, delete) - Authenticated users can manage formulas.
     * @principle Allows authenticated users to manage prescriptions. App-side queries filter by ownership.
     */
    match /formulas/{formulaId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // Allow all authenticated users to get and list
      // The app must filter queries by patientId or doctorId
      allow get, list: if isSignedIn();
      
      // Any authenticated user can create formulas (medical staff creates for patients)
      allow create: if isSignedIn();
      
      // Any authenticated user can update/delete (app-level checks control this)
      allow update, delete: if isSignedIn();
    }

    /**
     * @description Manages formula renewal requests.
     * @path /formulaRenewalRequests/{requestId}
     * @allow (create) - Patients can create renewal requests for their formulas
     * @allow (list, get) - Patients can read their own requests; Doctors can read requests assigned to them
     * @allow (update) - Doctors can update request status (approve/reject)
     * @deny (delete) - Requests should not be deleted for audit trail
     * @principle Patients request renewals; doctors review and respond
     * @fields patientId, doctorId, formulaId, medications, reason, status (pendiente/aprobada/rechazada), createdAt, respondedAt
     */
    match /formulaRenewalRequests/{requestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isPatient() {
        return request.auth != null && 
               request.resource.data.patientId == request.auth.uid;
      }

      function isRequestPatient() {
        return request.auth != null && 
               resource != null && 
               resource.data.patientId == request.auth.uid;
      }

      function isRequestDoctor() {
        return request.auth != null && 
               resource != null && 
               resource.data.doctorId == request.auth.uid;
      }

      // Patients can create renewal requests for themselves
      allow create: if isSignedIn() && isPatient() && 
                       request.resource.data.keys().hasAll(['formulaId', 'patientId', 'doctorId', 'medications', 'reason', 'status']) &&
                       request.resource.data.status == 'pendiente';
      
      // Patients can read their own requests; doctors can read requests assigned to them
      allow get: if isSignedIn() && (isRequestPatient() || isRequestDoctor());
      
      // For list queries: allow if authenticated (app-side queries filter by patientId or doctorId)
      allow list: if isSignedIn();
      
      // Doctors can update request status (approve/reject)
      // Only allow changing status and adding respondedAt field
      allow update: if isSignedIn() && 
                       isRequestDoctor() && 
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'respondedAt']) &&
                       request.resource.data.status in ['aprobada', 'rechazada'];
      
      // Don't allow deletion for audit trail
      allow delete: if false;
    }

    /**
     * @description Manages access to services collection.
     * @path /services/{serviceId}
     * @allow (get, list) - Authenticated users can read services.
     * @allow (create, update, delete) - Authenticated users can manage services.
     * @principle Allows authenticated users to view and manage medical services.
     */
    match /services/{serviceId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to shifts (work schedules) collection.
     * @path /shifts/{shiftId}
     * @allow (get, list) - Any authenticated user can read shifts (app-level filtering applies)
     * @allow (create, update, delete) - Any authenticated user can manage shifts (app-level controls apply)
     * @principle Simplified permissions - application handles role-based access control
     * @fields doctorId, doctorName, doctorRole, doctorSpecialty, startDate, endDate, startTime, endTime, type, durationHours, nocturno, recargoPercent, spansMidnight, area, observations, status
     * @status values: próximo, activo, finalizado (computed dynamically in client based on current time)
     */
    match /shifts/{shiftId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // Simplified: all authenticated users can read and write
      // Application layer enforces role-based restrictions
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Manages access to paciente_roles collection.
     * @path /paciente_roles/{userId}
     * @allow (get, list) - Authenticated users can read patient roles.
     * @allow (create) - Users can create their own patient role document during signup.
     * @allow (update, delete) - Authenticated users can manage patient roles.
     * @principle Allows users to create their patient role during registration.
     */
    match /paciente_roles/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get, list: if isSignedIn();
      allow create: if isOwner(userId);
      allow update, delete: if isSignedIn();
    }

    /**
     * @description Evolution notes (Notas de Evolución) - Medical progress notes written by doctors
     * @path /evolution_notes/{noteId}
     * @allow (create) - Authenticated medical staff (PERSONAL) can create notes
     * @allow (list, get) - Medical staff can read all notes; Patients can only read their own notes (where patientId matches their UID)
     * @deny (update, delete) - Notes are immutable once created for medical record integrity
     * @principle Medical staff documents patient progress; patients have read-only access to their own medical history
     */
    match /evolution_notes/{noteId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isPatientOwner() {
        return request.auth != null && resource != null && resource.data.patientId == request.auth.uid;
      }

      function isMedicalStaff() {
        return request.auth != null && 
               exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['PERSONAL', 'ADMIN'];
      }

      function isPatient() {
        return request.auth != null && 
               exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
               get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'PACIENTE';
      }

      // Medical staff can create notes with proper structure
      allow create: if isSignedIn() && isMedicalStaff() && 
                       request.resource.data.keys().hasAll(['patientId', 'doctorId', 'doctorName', 'content', 'date']) &&
                       request.resource.data.doctorId == request.auth.uid;
      
      // Medical staff can read all notes; patients can only read notes where they are the patient
      allow get: if isSignedIn() && (isMedicalStaff() || isPatientOwner());
      
      // For list queries: allow if medical staff OR if patient (app-side queries filter by patientId)
      allow list: if isSignedIn() && (isMedicalStaff() || isPatient());
      
      // Notes are immutable for medical record integrity
      allow update, delete: if false;
    }

    // Notifications collection
    // Structure: {
    //   userId: string,          // User who receives the notification
    //   type: string,            // 'appointment_confirmed', 'appointment_cancelled', 'diagnosis_ready', 'formula_created', 'note_added'
    //   title: string,           // Notification title
    //   message: string,         // Notification message
    //   read: boolean,           // Whether the notification has been read
    //   relatedId: string,       // ID of related document (appointmentId, formulaId, etc)
    //   createdAt: timestamp,    // When notification was created
    // }
    match /notifications/{notificationId} {
      allow create: if request.auth != null;
      allow read: if request.auth != null && resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && 
        resource.data.userId == request.auth.uid && 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }
  }
}